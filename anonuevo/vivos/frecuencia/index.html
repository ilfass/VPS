<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Frecuencia - Visualizador</title>
    <link href="../../css/styles.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            mix-blend-mode: overlay;
        }

        .freq-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10vw;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.05);
            letter-spacing: -5px;
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>
    <div class="overlay">
        <div class="freq-title">AUDIO_CORE</div>
    </div>
    <script type="module">
        // Simulación de Visualizador de Audio (Estilo Tunnel/Waves)
        // No depende de input de audio real para evitar problemas de permisos/silencio,
        // pero se mueve rítmicamente.
        // USAMOS THREE GLOBAL (cargado en <head>)

        const THREE = window.THREE;

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.05);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Geometría: Líneas ondulantes (Spectrum sim)
        const lines = [];
        const lineCount = 50;
        const width = 80;
        const segs = 64;

        const material = new THREE.LineBasicMaterial({
            color: 0x4a9eff,
            transparent: true,
            opacity: 0.8,
            vertexColors: true
        });

        for (let i = 0; i < lineCount; i++) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(segs * 3);
            const colors = new Float32Array(segs * 3);

            for (let j = 0; j < segs; j++) {
                positions[j * 3] = (j / (segs - 1)) * width - (width / 2);
                positions[j * 3 + 1] = 0;
                positions[j * 3 + 2] = (i - lineCount / 2) * 1.5;

                // Color gradient
                const color = new THREE.Color();
                color.setHSL((i / lineCount) * 0.5 + 0.5, 0.8, 0.5);
                colors[j * 3] = color.r;
                colors[j * 3 + 1] = color.g;
                colors[j * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const line = new THREE.Line(geometry, material);
            lines.push({ mesh: line, offset: i * 0.2 });
            scene.add(line);
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            const delta = clock.getDelta();

            // Rotar cámara suavemente
            camera.position.x = Math.sin(t * 0.1) * 5;
            camera.position.y = Math.cos(t * 0.15) * 2 + 5;
            camera.lookAt(0, 0, 0);

            // Animar ondas
            lines.forEach((l, idx) => {
                const positions = l.mesh.geometry.attributes.position.array;
                const waveSpeed = 2.0;

                // Simular "beat"
                const beat = Math.pow(Math.sin(t * 4), 4) * 2;

                for (let j = 0; j < segs; j++) {
                    const x = positions[j * 3];
                    // Formula simple de onda + ruido simulado de espectro
                    const noise = Math.sin(x * 0.5 + t * waveSpeed + l.offset)
                        * Math.cos(x * 0.2 - t * 0.5);
                    const y = noise * (2 + beat); // Altura afectada por "beat"

                    positions[j * 3 + 1] = y;
                }
                l.mesh.geometry.attributes.position.needsUpdate = true;

                // Opacidad pulsante
                const distOp = 1 - Math.abs(idx - lineCount / 2) / (lineCount / 2);
                l.mesh.material.opacity = distOp * (0.3 + beat * 0.1);
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
    <script type="module" src="../../js/main.js"></script>
</body>

</html>